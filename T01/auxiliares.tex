\section{Módulos auxiliares}
\subsection{Módulo Letra}
Se asume una implementación acorde\footnote{Una buena opción es usar un \href{https://en.wikipedia.org/wiki/Enumerated_type}{Enumerado}.} al módulo de género \texttt{letra} con las siguientes operaciones en la interfaz (todas con órden de complejidad $O(1)$):
\begin{itemize}
    \item $\textsc{dom}\quad :\quad\quad\quad \rightarrow\texttt{nat}$ \---- Tamaño del dominio del tipo \texttt{letra}. Corresponde con la variable $A$ de su especificación.
    \item $\textsc{ord}\quad:\texttt{letra}\rightarrow\texttt{nat}$ \---- Dada una letra, devuelve su correspondiente índice.
    \item $\textsc{ord}^{-1}: \texttt{nat}\ n\rightarrow\texttt{letra}\ \{n < A\}$ \---- Dado un índice, devuelve su correspondiente letra.
\end{itemize}

\subsection{Módulo Variante (Trie)}
\begin{interfaz}{\subsubsection{Interfaz}}
  \seExplica{Variante}{variante}\\
  \usa{\falta}
  \par\noindent
  \begin{operaciones}
    \InterfazFuncion{nuevaVariante}
    {
      \begin{adjustwidth}{2em}{}
      \In{n}{nat},\\
      \In{f}{nat},\\
      \In{puntajes}{dicc(letra, nat)},\\
      \In{legítimas}{conj(secu(letra))}
      \end{adjustwidth}
    }{variante}
    [$n>0\land f>0$]
    {$res\igobs nuevaVariante(n,f,puntajes,leg\acute{\imath}timas)$}
    [$O(\#leg\acute{\imath}timas\cdot\Lmax)$]
    [Genera una variante de juego.]
    [\falta]\\

    \noindent\InterfazFuncion{tamañoTablero}
    {\In{v}{variante}}{nat}
    [true]
    {$res\igobs tama\tilde{n}oTablero(v)$}
    [$O(1)$]
    [Devuelve el tamaño del tablero.]
    [\falta]\\

    \noindent\InterfazFuncion{fichasPorJugador}
    {\In{v}{variante}}{nat}
    [true]
    {$res\igobs \#fichas(v)$}
    [$O(1)$]
    [Devuelve la cantidad de fichas que debe de tener cada jugador.]
    [\falta]\\

    \noindent\InterfazFuncion{puntajeLetra}
    {\In{v}{variante}, \In{l}{letra}}{nat}
    [true]
    {$res\igobs puntajeLetra(v,l)$}
    [$O(1)$]
    [Devuelve el puntaje de una letra.]
    [\falta]\\

    \noindent\InterfazFuncion{palabraLegítima?}
    {\In{v}{variante}, \In{l}{secu(letra)}}{bool}
    [true]
    {$res\igobs palabraLeg\acute{\imath}tima(v,l)$}
    [$O(\Lmax)$]
    [Determina si una palabra es legítima dentro de la variante de juego.]
    [\falta]\\

    \noindent\InterfazFuncion{longPalabraMásLarga}
    {\In{v}{variante}}{nat}
    [true]
    {
      \begin{adjustwidth}{2em}{}

      $(\exists p:\texttt{secu(letra)})(res\igobs long(p)\land palabraLeg\acute{\imath}tima?(v,p)\land\\(\forall p_{2}:\texttt{secu(letra)})( palabraLeg\acute{\imath}tima?(v,p_{2})\implies res\geq long(p_{2})))$
      \end{adjustwidth}
    }
    [$O(1)$]
    [Obtiene la longitud de la palabra legítima más larga de la variante.]
    [\falta]
  \end{operaciones}
\end{interfaz}
\subsubsection{Implementación}

\subsection{Módulo Tablero}
\begin{interfaz}{\subsubsection{Interfaz}}
  \seExplica{Tablero}{tab}\\
  \usa{\falta}
  \par\noindent
  \begin{operaciones}
    \InterfazFuncion{nuevoTablero}
    {
      \In{n}{nat}
    }{tab}
    [$n>0$]
    {$res\igobs nuevoTablero(n)$}
    [$O(N^{2})$]
    [Genera un tablero de tamaño $n$.]
    [\falta]\\

    \noindent\InterfazFuncion{tamaño}
    {
      \In{t}{tab}
    }{nat}
    [true]
    {$res\igobs tama\tilde{n}o(t)$}
    [$O(1)$]
    [Devuelve tamaño del tablero.]
    [\falta]\\

    \noindent\InterfazFuncion{ponerLetra}
    {
      \In{t}{tab},
      \In{i}{nat},
      \In{j}{nat},
      \In{l}{letra},
      \In{tm}{nat}
    }{tab}
    [$enTablero(t,i,j)\yluego\lnot hayLetra?(t,i,j)$]
    {$res\igobs ponerLetra(t,i,j,l)$}
    [$O(1)$]
    [Pone una letra en la coordenada $(i,j)$.]
    [\falta]\\

    \noindent\InterfazFuncion{sacarLetra}
    {
      \In{t}{tab},
      \In{i}{nat},
      \In{j}{nat}
    }{tab}
    [$enTablero(t,i,j)\yluego hayLetra?(t,i,j)$]
    {$res$ es igual al tablero antes de haber puesto una letra en la coordenada $(i,j)$}
    [$O(1)$]
    [Saca una letra en la coordenada $(i,j)$.]
    [\falta]\\

    \noindent\InterfazFuncion{enTablero?}
    {\In{t}{tab}, \In{i}{nat}, \In{j}{nat}}{bool}
    [true]
    {$res\igobs enTablero?(t,i,j)$}
    [$O(1)$]
    [Determina si una coordenada $(i,j)$ está en el rango del tablero.]
    [\falta]\\

    \noindent\InterfazFuncion{hayLetra?}
    {\In{t}{tab}, \In{i}{nat}, \In{j}{nat}}{bool}
    [$enTablero?(t,i,j)$]
    {$res\igobs hayLetra?(t,i,j)$}
    [$O(1)$]
    [Determina si una celda del tablero dada una coordenada $(i,j)$ está ocupada por una letra.]
    [\falta]\\

    \noindent\InterfazFuncion{letra}
    {\In{t}{tab}, \In{i}{nat}, \In{j}{nat}}{letra}
    [$enTablero?(t,i,j)\yluego hayLetra?(t,i,j)$]
    {$res\igobs letra(t,i,j)$}
    [$O(1)$]
    [Obtiene la letra de una ficha del tablero dada una coordenada $(i,j)$.]
    [\falta]\\

    \noindent\InterfazFuncion{tiempo}
    {\In{t}{tab}, \In{i}{nat}, \In{j}{nat}}{nat}
    [$enTablero?(t,i,j)\yluego hayLetra?(t,i,j)$]
    {$res\igobs letra(t,i,j)$}
    [$O(1)$]
    [Obtiene el momento en que una ficha del tablero fue puesta dada una coordenada $(i,j)$.]
    [\falta]
  \end{operaciones}
\end{interfaz}
\subsubsection{Implementación}
\subsubsection*{Representación}
\begin{Estructura}{tab}[tab\_estr]
  \textbf{donde} \texttt{tab\_estr} es \texttt{array\_dimensionable(array\_dimensionable(puntero(tupla(letra,nat))))}
\end{Estructura}
\subsubsection*{Invariante de Representación}
\Rep[tab\_estr]{$
  (\forall i:\texttt{nat})(i<tam(tab\_estr)\impluego tam(tab\_estr[i])=tam(tab\_estr))
$}

\subsubsection*{Función de Abstracción}
\Abs[tab\_estr]{tab}[e]{T}{
  $
  tam(e)\igobs tama\tilde{n}o(T)\yluego\\
  (\forall i,j:\texttt{nat})((enTablero?(T,i,j)\yluego hayLetra?(T,i,j))\impluego
  $\begin{adjustwidth}{12em}{0em}$
  (e[i][j]\neq NULL\yluego letra(T,i,j)\igobs\pi_{1}(*e[i][j])))
  $\end{adjustwidth}$
  $
}

\subsubsection*{Algoritmos}
\begin{algorithm}[H]
  \defun{iNuevoTablero}{\In{n}{nat}}{tab\_estr}
  \begin{algorithmic}[1]
    \State\asignar{filas}{\textsc{CrearArreglo}(n)}
    \For{$columnas\in filas$}\Comment{$O(N)$}
        \State\asignar{columnas}{\textsc{CrearArreglo}(n)}
        \For{$celda\in columnas$}\Comment{$O(N)$}
          \State\asignar{celda}{\textsc{NULL}}
        \EndFor
    \EndFor
    \State\Return{res}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iTamaño}{\In{t}{tab\_estr}}{nat}
  \begin{algorithmic}[1]
    \State\Return{$tam(t)$}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defunv{iPonerLetra}{\Inout{t}{tab\_estr}, \In{i}{nat}, \In{j}{nat}, \In{l}{letra}, \In{tm}{nat}}
  \begin{algorithmic}[1]
    \State\asignar{t[i][j]}{\&\langle l,tm\rangle}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defunv{iSacarLetra}{\Inout{t}{tab\_estr}, \In{i}{nat}, \In{j}{nat}}
  \begin{algorithmic}[1]
    \State\asignar{t[i][j]}{\textsc{NULL}}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iEnTablero}{\In{t}{tab\_estr}, \In{i}{nat}, \In{j}{nat}}{bool}
  \begin{algorithmic}[1]
    \State\Return{$i<tam(t)\land j<tam(t)$}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iHayLetra}{\In{t}{tab\_estr}, \In{i}{nat}, \In{j}{nat}}{bool}
  \begin{algorithmic}[1]
    \State\Return{$t[i][j]\neq\textsc{NULL}$}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iLetra}{\In{t}{tab\_estr}, \In{i}{nat}, \In{j}{nat}}{letra}
  \begin{algorithmic}[1]
    \State\Return{$\pi_{1}(*t[i][j])$}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iTiempo}{\In{t}{tab\_estr}, \In{i}{nat}, \In{j}{nat}}{nat}
  \begin{algorithmic}[1]
    \State\Return{$\pi_{2}(*t[i][j])$}
  \end{algorithmic}
\end{algorithm}

\subsection{Módulo Ocurrencia}
Es renombre de \texttt{conj(tupla(nat,nat,letra))} con las siguientes operaciones auxiliares.\\\\
\begin{operaciones}
  \InterfazFuncion{esHorizontal?}
  {
    \In{o}{ocurrencia}
  }{bool}
  [true]
  {$res\igobs true\iff(\forall f,f':\texttt{tupla(nat,nat,letra)})(f,f'\in o\land f\neq f'\implies \pi_{2}(f)=\pi_{2}(f'))$}
  [$O(\#o^{2})$]
  [Determina si una ocurrencia está alineada horizontalmente.]
  [\falta]\\

  \noindent\InterfazFuncion{esVertical?}
  {
    \In{o}{ocurrencia}
  }{bool}
  [true]
  {$res\igobs true\iff(\forall f,f':\texttt{tupla(nat,nat,letra)})(f,f'\in o\land f\neq f'\implies \pi_{1}(f)=\pi_{1}(f'))$}
  [$O(\#o^{2})$]
  [Determina si una ocurrencia está alineada verticalmente.]
  [\falta]\\

  \noindent\InterfazFuncion{haySuperpuestas?}
  {
    \In{o}{ocurrencia}
  }{bool}
  [true]
  {$res\igobs false\iff
      (\forall p,q:\texttt{nat})(\forall l,l':\texttt{letra})(
      \{\langle p,q,l\rangle,\langle p,q,l'\rangle\}\subseteq o\implies l=l')$}
  [$O(\#o^{2})$]
  [Determina si existen fichas distintas en una misma coordenada.]
  [\falta]
\end{operaciones}

\subsubsection*{Algoritmos}
\begin{algorithm}[H]
  \defun{iEsHorizontal?}{\In{o}{ocurrencia}}{bool}
  \begin{algorithmic}[1]
    \State\asignar{colns}{\textsc{Vacío}()}\Comment{Conjunto Lineal}
    \For{$ $\asignar{oIt}{\textsc{CrearIt}(o)}$;\ \textsc{HaySiguiente}(oIt);\ \textsc{Avanzar}(oIt)$}\Comment{$O(\#o)$}
      \State\asignar{ficha}{\textsc{Siguiente}(oIt)}
      \State$\textsc{Agregar}(colns,\pi_{2}(ficha)))$\Comment{$O(\#o)$}
    \EndFor
    \State\Return{\textsc{Cardinal}(colns)=1}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iEsVertical?}{\In{o}{ocurrencia}}{bool}
  \begin{algorithmic}[1]
    \State\asignar{filas}{\textsc{Vacío}()}\Comment{Conjunto Lineal}
    \For{$ $\asignar{oIt}{\textsc{CrearIt}(o)}$;\ \textsc{HaySiguiente}(oIt);\ \textsc{Avanzar}(oIt)$}\Comment{$O(\#o)$}
      \State\asignar{ficha}{\textsc{Siguiente}(oIt)}
      \State$\textsc{Agregar}(filas,\pi_{1}(ficha)))$\Comment{$O(\#o)$}
    \EndFor
    \State\Return{\textsc{Cardinal}(filas)=1}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \defun{iHaySuperpuestas?}{\In{o}{ocurrencia}}{bool}
  \begin{algorithmic}[1]
    \For{$ $\asignar{oIt}{\textsc{CrearIt}(o)}$;\ \textsc{HaySiguiente}(oIt);\ \textsc{Avanzar}(oIt)$}\Comment{$O(\#o)$}
        \State\asignar{ficha}{\textsc{Siguiente}(oIt)}
        \For{$ $\asignar{oItSig}{\textsc{Avanzar}(copy(oIt))}$;\ \textsc{HaySiguiente}(oItSig);\ \textsc{Avanzar}(oItSig)$}\Comment{$O(\#o)$}
          \State\asignar{ficha'}{\textsc{Siguiente}(oItSig)}
          \If{$\pi_{1}(ficha)=\pi_{1}(fichaSig)\land\pi_{2}(ficha)=\pi_{2}(fichaSig)$}
          \State\Return true
          \EndIf
        \EndFor
    \EndFor
    \State\Return false
  \end{algorithmic}
\end{algorithm}

\subsection{Módulo Notificación}
Asumimos que existe el tipo notif

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
